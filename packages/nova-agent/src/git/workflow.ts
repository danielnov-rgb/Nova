import fs from 'fs';
import path from 'path';
import simpleGit, { SimpleGit } from 'simple-git';
import type { FileChange } from '../types.js';

export async function createGitBranch(
  repoPath: string,
  branchName: string,
  changes: FileChange[]
): Promise<void> {
  const git: SimpleGit = simpleGit(repoPath);

  // Check if we're in a git repo
  const isRepo = await git.checkIsRepo();
  if (!isRepo) {
    throw new Error('Not a git repository. Initialize git first: git init');
  }

  // Check for uncommitted changes
  const status = await git.status();
  if (status.modified.length > 0 || status.staged.length > 0) {
    throw new Error(
      'You have uncommitted changes. Please commit or stash them first.'
    );
  }

  // Get current branch to return to later if needed
  const currentBranch = status.current;

  // Check if branch already exists
  const branches = await git.branchLocal();
  if (branches.all.includes(branchName)) {
    // Checkout existing branch
    await git.checkout(branchName);
  } else {
    // Create and checkout new branch
    await git.checkoutLocalBranch(branchName);
  }

  try {
    // Apply changes
    for (const change of changes) {
      const fullPath = path.join(repoPath, change.path);
      const dir = path.dirname(fullPath);

      // Ensure directory exists
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Write file
      fs.writeFileSync(fullPath, change.content);
    }

    // Stage all changes
    const filesToAdd = changes.map((c) => c.path);
    await git.add(filesToAdd);

    // Create commit
    const commitMessage = `feat: Add Nova analytics tracking

Generated by nova-agent

Changes:
${changes.map((c) => `- ${c.operation === 'create' ? 'Created' : 'Modified'} ${c.path}`).join('\n')}
`;

    await git.commit(commitMessage);

    // Try to push
    try {
      await git.push('origin', branchName, ['--set-upstream']);
    } catch (pushError) {
      // Push failed - might not have a remote
      console.warn(
        '\nWarning: Could not push to remote. Changes are committed locally.'
      );
      console.warn('You can push manually: git push -u origin ' + branchName);
    }
  } catch (error) {
    // If something goes wrong, try to return to original branch
    if (currentBranch) {
      await git.checkout(currentBranch).catch(() => {});
    }
    throw error;
  }
}

export async function showDiff(
  repoPath: string,
  changes: FileChange[]
): Promise<string> {
  const diffs: string[] = [];

  for (const change of changes) {
    const fullPath = path.join(repoPath, change.path);

    if (change.operation === 'create') {
      diffs.push(`+++ ${change.path} (new file)`);
      diffs.push(
        change.content
          .split('\n')
          .map((line) => `+ ${line}`)
          .join('\n')
      );
    } else {
      // Show diff for existing file
      if (fs.existsSync(fullPath)) {
        const oldContent = fs.readFileSync(fullPath, 'utf-8');
        diffs.push(`--- ${change.path}`);
        diffs.push(`+++ ${change.path}`);
        diffs.push(simpleDiff(oldContent, change.content));
      }
    }

    diffs.push('');
  }

  return diffs.join('\n');
}

function simpleDiff(oldContent: string, newContent: string): string {
  const oldLines = oldContent.split('\n');
  const newLines = newContent.split('\n');
  const result: string[] = [];

  // Very simple diff - just show what's different
  const maxLen = Math.max(oldLines.length, newLines.length);

  for (let i = 0; i < maxLen; i++) {
    const oldLine = oldLines[i] ?? '';
    const newLine = newLines[i] ?? '';

    if (oldLine !== newLine) {
      if (oldLines[i] !== undefined) {
        result.push(`- ${oldLine}`);
      }
      if (newLines[i] !== undefined) {
        result.push(`+ ${newLine}`);
      }
    }
  }

  return result.join('\n');
}
